|失败用例|失败原因|失败类型|解决方法|
|:---:|:---:|:---:|:---:|
|keyctl03|概率失败|概率失败|多重试几次，用例PASS|
|mallinfo01|与glibc有关，openeuler配套的glibc是2.28|与glibc有关|建议升级glibc|
|sched_rr_get_interval01|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|sched_rr_get_interval02|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|sched_rr_get_interval03|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|sched_setparam02|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|sched_setparam03|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|sched_getscheduler01|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|perf_event_open02|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|time-schedule01|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|trace_sched01|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
|memcg_stress|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_function_memory|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_2_2_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_3_3_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_4_4_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_2_9_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_10_3_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_1_200_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_200_1_none|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_2_2_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_3_3_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_4_4_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_2_9_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_10_3_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_1_200_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_200_1_one|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_2_2_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_3_3_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_4_4_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_2_9_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_10_3_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_1_200_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cgroup_fj_stress_memory_200_1_each|系统自带的/sys/fs/cgroup/memory会影响syscgroup的创建，导致用例失败|用例问题|1、将/sys/fs/cgroup/memory先umount，用例能PASS<br>2、最好的解决方法是修改LTP的cgroup用例，先将影响用例的cgroup目录卸载掉<br>3、LTP社区最近也在重构cgroup的用例|
|cpuset_hotplug|lscpu查看到的CPU是0-31<br>但是cat /proc/$tst_pid/status &brvbar; grep Cpus_allowed_list查询到是0-63，导致用例在比对这两个值时失败|用例问题|1、Cpus_allowed_list的值是与/sys/devices/system/cpu/possible - /sys/devices/system/cpu/isolated保持一致的，possible是BIOS给预留的CPU（可后续提供热插CPU用），/sys/devices/system/cpu/isolated是隔离的CPU，Cpus_allowed_list这个不是真实的online CPU个数<br>2、建议修改LTP用例，对比/sys/devices/system/cpu/present的值，提交patch到社区|
|cpuset_memory_pressure|环境中无swap分区，用例在加压到临界值时无其他申请内存的渠道，导致OOM，用例失败|用例问题|1、添加8G的swap分区后重测用例，PASS<br>2、修改用例，考虑无swap场景，提交patch到社区|
|cpuhotplug03|前序用例cpuset_sched_domains导致cpu拓扑变为NULL，影响此用例|前序用例影响|重启单板之后，用例PASS|
|cve-2016-7042|概率失败|概率失败|多重试几次，用例PASS|
|cve-2019-8912|前序用例cpuset_sched_domains导致cpu拓扑变为NULL，影响此用例|前序用例影响|重启单板之后，用例PASS|
|af_alg07|前序用例cpuset_sched_domains导致cpu拓扑变为NULL，影响此用例|前序用例影响|重启单板之后，用例PASS|
|cpufreq_boost|/sys/fs/cgroup/cpu,cpuacct/user.slice/cpu.rt_runtime_us<br>这个值系统中为0，导致CPU调度的相关策略被禁用|前序用例影响|修改为950000，保持跟/sys/fs/cgroup/cpu,cpuacct/cpu.rt_runtime_us一致|
